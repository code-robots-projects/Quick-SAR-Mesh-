<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>868MHz Fresnel Mesh Planner</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        :root { 
            --primary: #2c3e50; 
            --mesh-blue: #3498db; 
            --danger: #e74c3c; 
            --warning: #f1c40f; 
            --success: #2ecc71; 
            --bg: #f8f9fa;
            --accent: #9b59b6;
            --desperation: #e67e22;
        }
        body { margin: 0; padding: 0; font-family: -apple-system, system-ui, sans-serif; overflow: hidden; background: var(--bg); }
        
        #map { height: 100vh; width: 100vw; z-index: 1; transition: filter 0.5s ease; }
        
        #controls {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            z-index: 1000; background: white; padding: 18px; border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2); width: 90%; max-width: 480px;
            border: 1px solid rgba(0,0,0,0.05);
        }

        .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
        .title-group h1 { font-size: 1rem; margin: 0; color: var(--primary); font-weight: 800; letter-spacing: -0.5px; }
        .title-group p { font-size: 0.65rem; margin: 0; color: #7f8c8d; text-transform: uppercase; font-weight: 600; }
        
        .status-badge { font-size: 0.7rem; font-weight: 800; padding: 4px 8px; border-radius: 20px; background: #eee; transition: all 0.3s; }
        
        .btn-group { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 10px; }
        button { 
            padding: 12px; border: none; border-radius: 10px; cursor: pointer; 
            font-weight: 700; font-size: 0.75rem; transition: all 0.2s ease;
            display: flex; align-items: center; justify-content: center; gap: 6px;
        }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-main { background: var(--mesh-blue); color: white; }
        .btn-calc { background: var(--success); color: white; grid-column: span 2; display: none; }
        .btn-alt { background: #f1f2f6; color: var(--primary); }
        .btn-export { background: #34495e; color: white; }

        #processing-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(44, 62, 80, 0.4); z-index: 1500;
            display: none; flex-direction: column; align-items: center; justify-content: center;
            backdrop-filter: blur(4px); pointer-events: none;
        }
        
        .loader-box { background: white; padding: 25px; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.3); text-align: center; min-width: 280px; }

        #prompt-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(44, 62, 80, 0.8); z-index: 2000;
            display: none; align-items: center; justify-content: center;
        }
        .modal { background: white; padding: 25px; border-radius: 20px; text-align: left; max-width: 320px; width: 90%; }
        .modal h3 { margin-top: 0; text-align: center; font-size: 1.1rem; color: var(--primary); }
        .input-row { margin-bottom: 15px; }
        .input-row label { display: block; font-size: 0.7rem; font-weight: 800; color: #666; margin-bottom: 5px; }
        .modal input { width: 100%; padding: 12px; border: 2px solid #eee; border-radius: 10px; font-size: 1rem; box-sizing: border-box; }

        #mesh-summary { margin-top: 12px; padding-top: 12px; border-top: 1px dashed #ddd; font-size: 0.85rem; display: none; }
        .log { max-height: 80px; overflow-y: auto; font-size: 0.75rem; color: #666; margin-top: 5px; background: #fdfdfd; padding: 8px; border-radius: 4px; border: 1px solid #eee; }
        
        #profile-viewer {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            width: 90%; max-width: 600px; background: white; z-index: 2000;
            border-radius: 12px; box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            display: none; padding: 15px;
        }
        #profile-canvas { width: 100%; height: 150px; background: #f9f9f9; border-radius: 8px; }
        .profile-stats { display: flex; justify-content: space-between; margin-top: 10px; font-size: 0.75rem; color: var(--primary); font-weight: 600; }

        .repeater-pulse { 
            background: var(--accent); border-radius: 50%; 
            box-shadow: 0 0 0 rgba(155, 89, 182, 0.4); 
            animation: pulse 2s infinite; 
            display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 10px;
            border: 2px solid white;
        }
        .desperation-pulse {
            background: var(--desperation); border-radius: 50%; 
            box-shadow: 0 0 0 rgba(230, 126, 34, 0.4); 
            animation: pulse-orange 1s infinite; 
            display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 10px;
            border: 2px solid white;
        }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(155, 89, 182, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(155, 89, 182, 0); } 100% { box-shadow: 0 0 0 0 rgba(155, 89, 182, 0); } }
        @keyframes pulse-orange { 0% { box-shadow: 0 0 0 0 rgba(230, 126, 34, 0.7); } 50% { box-shadow: 0 0 0 15px rgba(230, 126, 34, 0); } 100% { box-shadow: 0 0 0 0 rgba(230, 126, 34, 0); } }
    </style>
</head>
<body>

<div id="processing-overlay">
    <div class="loader-box">
        <div style="font-weight: 800; color: var(--primary); font-size: 1.1rem;">ROADSIDE MESH SOLVER</div>
        <div id="proc-label" style="font-size: 0.8rem; color: #666; margin-top: 10px;">Generating Cost Surface...</div>
        <div style="width: 100%; background: #eee; height: 4px; border-radius: 2px; margin-top: 15px; overflow: hidden;">
            <div id="proc-bar" style="width: 0%; height: 100%; background: var(--success); transition: width 0.3s;"></div>
        </div>
        <div id="proc-sub-label" style="font-size: 0.65rem; color: #999; margin-top: 8px;">Max 15km hops (6dBi) from road nodes...</div>
    </div>
</div>

<div id="prompt-overlay">
    <div class="modal">
        <h3>Deployment Mission</h3>
        <div class="input-row">
            <label>POINTS TO REACH</label>
            <input type="number" id="node-count-input" value="1" min="1" max="20">
        </div>
        <div class="input-row">
            <label>PREFERRED REPEATER LIMIT</label>
            <input type="number" id="repeater-budget-input" value="5" min="1" max="100">
        </div>
        <button class="btn-main" style="width: 100%" onclick="confirmDeploymentSetup()">Begin Mission</button>
    </div>
</div>

<div id="profile-viewer">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
        <span id="profile-title" style="font-weight:800; font-size:0.8rem;">LINK ANALYSIS</span>
        <button onclick="closeProfile()" style="padding:4px 8px; font-size:10px;">CLOSE</button>
    </div>
    <canvas id="profile-canvas"></canvas>
    <div class="profile-stats">
        <span id="stat-dist">Distance: -- km</span>
        <span id="stat-clear">Clearance: -- %</span>
    </div>
    <div id="stat-coords" style="font-size: 0.6rem; color: #999; margin-top: 5px; text-align: center;"></div>
</div>

<div id="controls">
    <div class="header">
        <div class="title-group">
            <h1>Roadside Mesh Planner</h1>
            <p id="ui-subtitle">6dBi Antennas (15km Max Hop)</p>
        </div>
        <div id="step-badge" class="status-badge">STEP 1</div>
    </div>
    
    <div id="mesh-summary">
        <div style="display:flex; justify-content:space-between; font-weight:bold;">
            <span>LCP Engine</span>
            <span id="mesh-status-text" style="color: #7f8c8d">Standby</span>
        </div>
        <div id="mesh-log" class="log"></div>
    </div>

    <div class="btn-group">
        <button class="btn-main" id="add-node-btn" onclick="triggerAddNode()">üìç Place Point</button>
        <button class="btn-alt" onclick="resetApp()">üóëÔ∏è Reset All</button>
        <button class="btn-export" id="export-btn" onclick="exportKML()" disabled>üíæ Export KML</button>
        <button class="btn-alt" onclick="resetMapOnly()">üîÑ Clear Map</button>
        <button class="btn-calc" id="calc-btn" onclick="runMeshOptimization()">‚ö° CALCULATE LCP</button>
    </div>
</div>

<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
    let map, tileCache = new Map();
    let nodes = []; 
    let repeaters = []; 
    let polylines = [];
    let roadPoints = [];
    let existingLinkKeys = new Set(); 
    let connectedNodeIds = new Set([0]); 
    let activeLinks = [];
    let targetNodeCount = 0;
    let repeaterBudget = 0;
    let currentStep = 'BASE';
    let repeaterCounter = 1;
    
    const ANT_H = 10.0;
    const FREQ_GHZ = 0.868;
    const EARTH_K = 1.333;
    const EARTH_R = 6371;
    const ZOOM_LEVEL = 12;
    const ROAD_THRESHOLD_M = 500; 
    const MAX_HOP_KM = 15; // 15km for 6dBi

    const COLORS = {
        primary: '#2c3e50',
        meshBlue: '#3498db',
        danger: '#e74c3c',
        warning: '#f1c40f',
        success: '#2ecc71',
        accent: '#9b59b6',
        desperation: '#e67e22'
    };

    function init() {
        map = L.map('map', { zoomControl: false, tap: true }).setView([-33.95, 18.85], 11);
        L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
            maxZoom: 17,
            attribution: 'Map data: &copy; OpenStreetMap contributors, SRTM | Map style: &copy; OpenTopoMap (CC-BY-SA)'
        }).addTo(map);
        map.on('click', (e) => handleMapInput(e.latlng));
    }

    const decodeHeight = (r, g, b) => (r * 256 + g + b / 256) - 32768;
    const lon2tile = (lon, z) => Math.floor((lon + 180) / 360 * Math.pow(2, z));
    const lat2tile = (lat, z) => Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, z));

    async function getElevation(lat, lng) {
        const x = lon2tile(lng, ZOOM_LEVEL);
        const y = lat2tile(lat, ZOOM_LEVEL);
        const key = `${ZOOM_LEVEL}/${x}/${y}`;
        if (!tileCache.has(key)) {
            try {
                const img = new Image(); img.crossOrigin = "Anonymous";
                await new Promise((res, rej) => {
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = 256; canvas.height = 256;
                        canvas.getContext('2d').drawImage(img, 0, 0);
                        tileCache.set(key, canvas); res();
                    };
                    img.onerror = rej;
                    img.src = `https://s3.amazonaws.com/elevation-tiles-prod/terrarium/${ZOOM_LEVEL}/${x}/${y}.png`;
                });
            } catch (e) { return 0; }
        }
        const canvas = tileCache.get(key);
        if (!canvas) return 0;
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const n = Math.pow(2, ZOOM_LEVEL);
        const px = Math.floor(((lng + 180) / 360 * n % 1) * 256);
        const py = Math.floor(((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * n % 1) * 256);
        const p = ctx.getImageData(px, py, 1, 1).data;
        return decodeHeight(p[0], p[1], p[2]);
    }

    function triggerAddNode() {
        if (currentStep === 'OPTIMIZING') return;
        map.locate({setView: true, maxZoom: 12});
        map.once('locationfound', (e) => handleMapInput(e.latlng));
    }

    async function handleMapInput(latlng) {
        if (currentStep === 'BASE') {
            const marker = L.circleMarker(latlng, { radius: 12, color: 'white', fillColor: COLORS.primary, fillOpacity: 1, weight: 3 }).addTo(map);
            nodes.push({ latlng, marker, type: 'BASE', id: 0 });
            document.getElementById('prompt-overlay').style.display = 'flex';
        } else if (currentStep === 'NODES') {
            const marker = L.circleMarker(latlng, { radius: 10, color: 'white', fillColor: COLORS.meshBlue, fillOpacity: 1, weight: 2 }).addTo(map);
            nodes.push({ latlng, marker, type: 'FIELD', id: nodes.length });
            if (nodes.length - 1 === targetNodeCount) {
                currentStep = 'READY_CALC';
                document.getElementById('add-node-btn').style.display = 'none';
                document.getElementById('calc-btn').style.display = 'flex';
                updateUI(`Points Defined`, `READY`, COLORS.success);
            } else {
                updateUI(`Mark ${targetNodeCount - (nodes.length - 1)} More Points`, `STEP 2`, COLORS.meshBlue);
            }
        }
    }

    function confirmDeploymentSetup() {
        targetNodeCount = parseInt(document.getElementById('node-count-input').value);
        repeaterBudget = parseInt(document.getElementById('repeater-budget-input').value);
        document.getElementById('prompt-overlay').style.display = 'none';
        currentStep = 'NODES';
        document.getElementById('mesh-summary').style.display = 'block';
        updateUI(`Mark ${targetNodeCount} Points to Reach`, `STEP 2`, COLORS.meshBlue);
        logToMesh(`Mission: Connect ${targetNodeCount} points.`);
    }

    async function runMeshOptimization() {
        document.getElementById('processing-overlay').style.display = 'flex';
        document.getElementById('calc-btn').disabled = true;
        currentStep = 'OPTIMIZING';
        connectedNodeIds = new Set([0]);
        
        repeaters.forEach(r => map.removeLayer(r.marker));
        polylines.forEach(p => map.removeLayer(p));
        repeaters = []; polylines = []; repeaterCounter = 1; existingLinkKeys = new Set(); activeLinks = [];
        
        logToMesh(`Generating Cost Surface (Roads & Terrain)...`);
        await fetchLocalRoads();
        
        const costSurface = await generateCostSurface(); 

        const targetPoints = nodes.slice(1);
        for (let i = 0; i < targetPoints.length; i++) {
            const target = targetPoints[i];
            document.getElementById('proc-bar').style.width = `${Math.floor((i / targetPoints.length) * 100)}%`;
            document.getElementById('proc-label').innerText = `Calculating Least Cost Path to Point ${target.id}...`;
            
            // Try direct existing mesh first
            let reached = await tryBridgeToExistingMesh(target);
            if (!reached) {
                // Determine best start point in mesh
                const network = [...nodes.filter(n => connectedNodeIds.has(n.id)), ...repeaters];
                let bestStart = nodes[0];
                let minDist = Infinity;
                network.forEach(pt => {
                    const d = pt.latlng.distanceTo(target.latlng);
                    if (d < minDist) { minDist = d; bestStart = pt; }
                });
                
                logToMesh(`Solving A* path from Mesh to Node ${target.id}...`);
                const chain = await findLeastCostRadioPath(bestStart, target, costSurface);
                
                if (chain) {
                    let prevNode = bestStart;
                    for (let pt of chain) {
                        const rep = createRepeater(pt);
                        await drawInteractiveLink(prevNode.latlng, rep.latlng);
                        prevNode = rep;
                        connectedNodeIds.add(rep.id);
                    }
                    await drawInteractiveLink(prevNode.latlng, target.latlng);
                    connectedNodeIds.add(target.id);
                    logToMesh(`Path established via ${chain.length} hops.`);
                } else {
                    logToMesh(`CRITICAL: No path found for Node ${target.id}.`);
                }
            }
        }

        document.getElementById('processing-overlay').style.display = 'none';
        document.getElementById('export-btn').disabled = false;
        updateUI("Solver Complete", "DONE", COLORS.success);
        const health = Math.round((connectedNodeIds.size / nodes.length) * 100);
        const overBudget = repeaters.length > repeaterBudget ? ` (+${repeaters.length - repeaterBudget} Extra)` : "";
        document.getElementById('mesh-status-text').innerText = `${health}% Coverage | ${repeaters.length} Relays${overBudget}`;
    }

    async function tryBridgeToExistingMesh(target) {
        const network = [...nodes.filter(n => connectedNodeIds.has(n.id)), ...repeaters];
        for (let pt of network) {
            const path = await calculatePath(pt.latlng, target.latlng);
            if (path.clearance > 0.3) {
                await drawInteractiveLink(pt.latlng, target.latlng);
                connectedNodeIds.add(target.id);
                return true;
            }
        }
        return false;
    }

    // --- LEAST COST PATH ENGINE ---

    async function generateCostSurface() {
        // Calculate Bounding Box of all nodes
        const lats = nodes.map(n => n.latlng.lat);
        const lngs = nodes.map(n => n.latlng.lng);
        const minLat = Math.min(...lats) - 0.1; // ~10km buffer
        const maxLat = Math.max(...lats) + 0.1;
        const minLng = Math.min(...lngs) - 0.1;
        const maxLng = Math.max(...lngs) + 0.1;

        let surface = [];
        const steps = 80; // High resolution grid
        
        for(let i=0; i<=steps; i++) {
            for(let j=0; j<=steps; j++) {
                const lat = minLat + ((maxLat - minLat) * (i/steps));
                const lng = minLng + ((maxLng - minLng) * (j/steps));
                const pt = L.latLng(lat, lng);
                
                const closestRoad = findClosestRoad(pt);
                const distToRoad = closestRoad ? pt.distanceTo(closestRoad) : 10000;
                const isRoadside = distToRoad < ROAD_THRESHOLD_M;
                
                const alt = await getElevation(pt.lat, pt.lng);
                
                // COST CALCULATION
                let cost = 10;
                if (!isRoadside) cost += 100; // Expensive to go offroad
                cost -= (alt / 50); // High ground is attractive
                if (cost < 1) cost = 1; // Minimum cost

                surface.push({ latlng: pt, alt, isRoadside, cost });
            }
        }
        
        // Add specific road points to surface to ensure connectivity
        const roadStep = Math.floor(roadPoints.length / 800) + 1; 
        for (let i = 0; i < roadPoints.length; i += roadStep) {
            const pt = roadPoints[i];
            // Only add if within bounds
            if (pt.lat >= minLat && pt.lat <= maxLat && pt.lng >= minLng && pt.lng <= maxLng) {
                const alt = await getElevation(pt.lat, pt.lng);
                surface.push({ latlng: pt, alt, isRoadside: true, cost: 1 });
            }
        }
        
        return surface;
    }

    async function findLeastCostRadioPath(startNode, endNode, surface) {
        // A* Algorithm
        
        let openSet = [];
        let cameFrom = new Map();
        let gScore = new Map(); // Cost from start
        let fScore = new Map(); // Estimated total cost
        
        const startPt = { latlng: startNode.latlng, cost: 0, id: 'start' };
        const endPt = { latlng: endNode.latlng, cost: 0, id: 'end' };
        
        const totalDist = startNode.latlng.distanceTo(endNode.latlng);
        // Tighter search area
        const candidates = surface.filter(p => {
            const d1 = p.latlng.distanceTo(startNode.latlng);
            const d2 = p.latlng.distanceTo(endNode.latlng);
            return (d1 + d2) < totalDist * 1.5; 
        });
        candidates.push(endPt);

        gScore.set(startPt, 0);
        fScore.set(startPt, totalDist / 1000); 
        openSet.push(startPt);
        
        let loops = 0;
        
        while(openSet.length > 0 && loops < 5000) {
            loops++;
            openSet.sort((a,b) => (fScore.get(a) || Infinity) - (fScore.get(b) || Infinity));
            const current = openSet.shift();
            
            if (current === endPt) {
                return reconstructPath(cameFrom, current);
            }
            
            // To be faster: sort by distance to end
            candidates.sort((a,b) => a.latlng.distanceTo(endNode.latlng) - b.latlng.distanceTo(endNode.latlng));
            
            let neighborsChecked = 0;
            
            for(let neighbor of candidates) {
                if (neighbor === current) continue;
                
                const dist = current.latlng.distanceTo(neighbor.latlng);
                if (dist > (MAX_HOP_KM * 1000) || dist < 200) continue; // Max 15km per hop (6dBi)
                
                neighborsChecked++;
                if (neighborsChecked > 60) break; // Limit fan-out
                
                const path = await calculatePath(current.latlng, neighbor.latlng);
                if (path.clearance > 0.3) {
                    const edgeCost = neighbor.cost + 20; 
                    const tentative_gScore = gScore.get(current) + edgeCost;
                    
                    if (tentative_gScore < (gScore.get(neighbor) || Infinity)) {
                        cameFrom.set(neighbor, current);
                        gScore.set(neighbor, tentative_gScore);
                        const h = neighbor.latlng.distanceTo(endNode.latlng) / 1000 * 5; 
                        fScore.set(neighbor, tentative_gScore + h);
                        
                        if (!openSet.includes(neighbor)) {
                            openSet.push(neighbor);
                        }
                    }
                }
            }
        }
        return null;
    }

    function reconstructPath(cameFrom, current) {
        let totalPath = [];
        while (cameFrom.has(current)) {
            if (current.id !== 'end') totalPath.unshift(current); 
            current = cameFrom.get(current);
        }
        return totalPath;
    }

    async function fetchLocalRoads() {
        // Fetch roads for the entire mission area
        let bounds;
        if (nodes.length > 0) {
             const lats = nodes.map(n => n.latlng.lat);
             const lngs = nodes.map(n => n.latlng.lng);
             const buffer = 0.15; 
             bounds = {
                 getSouth: () => Math.min(...lats) - buffer,
                 getNorth: () => Math.max(...lats) + buffer,
                 getWest: () => Math.min(...lngs) - buffer,
                 getEast: () => Math.max(...lngs) + buffer
             };
        } else {
             bounds = map.getBounds();
        }

        const query = `[out:json];way["highway"~"primary|secondary|tertiary|motorway|trunk|unclassified|residential|track"](${bounds.getSouth()},${bounds.getWest()},${bounds.getNorth()},${bounds.getEast()});(._;>;);out body;`;
        try {
            const resp = await fetch('https://overpass-api.de/api/interpreter', { method: 'POST', body: query });
            const data = await resp.json();
            roadPoints = data.elements.filter(e => e.type === 'node').map(e => L.latLng(e.lat, e.lon));
            logToMesh(`Road data loaded: ${roadPoints.length} points.`);
        } catch(e) { 
            logToMesh("Road data fetch failed or empty.");
            roadPoints = []; 
        }
    }

    function findClosestRoad(pt) {
        if (!roadPoints.length) return null;
        let minD = Infinity, match = null;
        const step = Math.floor(roadPoints.length / 1000) + 1;
        for (let i = 0; i < roadPoints.length; i+=step) {
            const rp = roadPoints[i];
            const d = pt.distanceTo(rp);
            if (d < minD) { minD = d; match = rp; }
            if (minD < 50) break;
        }
        return match;
    }

    function createRepeater(data) {
        const existing = repeaters.find(r => r.latlng.distanceTo(data.latlng) < 100);
        if (existing) return existing;
        
        const isOverBudget = repeaterCounter > repeaterBudget + 1;
        const pulseClass = isOverBudget || !data.isRoadside ? 'desperation-pulse' : 'repeater-pulse';
        
        const icon = L.divIcon({ className: pulseClass, html: `<span>${repeaterCounter++}</span>`, iconSize: [26, 26] });
        const marker = L.marker(data.latlng, { icon }).addTo(map);
        const rep = { latlng: data.latlng, marker, id: `R${repeaterCounter-1}`, roadside: data.isRoadside };
        repeaters.push(rep);
        
        if (isOverBudget) logToMesh(`EXTRA RELAY ${rep.id} added (Over Budget).`);
        if (!data.isRoadside) logToMesh(`RELAY ${rep.id} IS OFF-ROAD (Desperation).`);
        
        return rep;
    }

    async function calculatePath(p1, p2) {
        const dist = p1.distanceTo(p2);
        const samples = 30; 
        let minClearance = 100, points = [];
        const h1 = await getElevation(p1.lat, p1.lng) + ANT_H;
        const h2 = await getElevation(p2.lat, p2.lng) + ANT_H;

        for (let i = 0; i <= samples; i++) {
            const f = i / samples;
            const lat = p1.lat + (p2.lat - p1.lat) * f;
            const lng = p1.lng + (p2.lng - p1.lng) * f;
            const terrainH = await getElevation(lat, lng);
            const d1 = dist * f;
            const d2 = dist * (1 - f);
            const curv = (d1 * d2) / (2 * EARTH_K * EARTH_R * 1000);
            const fRadius = 17.32 * Math.sqrt(((d1/1000)*(d2/1000))/(FREQ_GHZ*(dist/1000 + 0.001)));
            const rayH = h1 + (h2 - h1) * f - curv;
            const clearance = (rayH - terrainH) / (fRadius || 1);
            if (clearance < minClearance) minClearance = clearance;
            points.push({ terrainH, rayH, fRadius, dist: d1 });
        }
        return { 
            color: minClearance < 0 ? COLORS.danger : (minClearance < 0.3 ? COLORS.warning : COLORS.success), 
            clearance: minClearance, 
            points, 
            dist,
            latlngs: [p1, p2]
        };
    }

    async function drawInteractiveLink(p1, p2) {
        const key = [p1.lat.toFixed(5), p1.lng.toFixed(5), p2.lat.toFixed(5), p2.lng.toFixed(5)].sort().join(',');
        if (existingLinkKeys.has(key)) return;
        const path = await calculatePath(p1, p2);
        existingLinkKeys.add(key);
        activeLinks.push(path);
        const poly = L.polyline([p1, p2], { color: path.color, weight: 4, opacity: 0.85 }).addTo(map);
        poly.on('click', (e) => { L.DomEvent.stopPropagation(e); showProfile(path); });
        polylines.push(poly);
    }

    function showProfile(path) {
        const panel = document.getElementById('profile-viewer');
        const canvas = document.getElementById('profile-canvas');
        panel.style.display = 'block';
        document.getElementById('stat-dist').innerText = `Distance: ${(path.dist / 1000).toFixed(2)} km`;
        document.getElementById('stat-clear').innerText = `Fresnel Clear: ${Math.max(0, Math.round(path.clearance * 100))}%`;
        const start = path.latlngs[0];
        const end = path.latlngs[1];
        document.getElementById('stat-coords').innerText = `Path: ${start.lat.toFixed(3)},${start.lng.toFixed(3)} to ${end.lat.toFixed(3)},${end.lng.toFixed(3)}`;

        const ctx = canvas.getContext('2d');
        const w = canvas.width = canvas.offsetWidth;
        const h = canvas.height = canvas.offsetHeight;
        const allHeights = path.points.flatMap(p => [p.terrainH, p.rayH + p.fRadius, p.rayH - p.fRadius]);
        const minH = Math.min(...allHeights) - 10;
        const maxH = Math.max(...allHeights) + 10;
        const range = maxH - minH;
        const getY = (v) => h - ((v - minH) / range) * h;
        const getX = (d) => (d / path.dist) * w;
        
        ctx.clearRect(0, 0, w, h);
        ctx.fillStyle = 'rgba(52, 152, 219, 0.15)';
        ctx.beginPath();
        path.points.forEach((p, i) => { if (i === 0) ctx.moveTo(getX(p.dist), getY(p.rayH + p.fRadius)); else ctx.lineTo(getX(p.dist), getY(p.rayH + p.fRadius)); });
        for (let i = path.points.length - 1; i >= 0; i--) ctx.lineTo(getX(path.points[i].dist), getY(path.points[i].rayH - path.points[i].fRadius));
        ctx.closePath(); ctx.fill();
        
        ctx.fillStyle = '#95a5a6';
        ctx.beginPath(); ctx.moveTo(0, h);
        path.points.forEach(p => ctx.lineTo(getX(p.dist), getY(p.terrainH)));
        ctx.lineTo(w, h); ctx.closePath(); ctx.fill();
        
        ctx.strokeStyle = '#2c3e50'; ctx.setLineDash([2, 4]);
        ctx.beginPath(); ctx.moveTo(0, getY(path.points[0].rayH)); ctx.lineTo(w, getY(path.points[path.points.length-1].rayH)); ctx.stroke();
    }

    function exportKML() {
        let kml = `<?xml version="1.0" encoding="UTF-8"?><kml xmlns="http://www.opengis.net/kml/2.2"><Document><name>Roadside Mesh Plan</name>`;
        nodes.forEach((n, i) => kml += `<Placemark><name>${i === 0 ? 'Command Center' : 'Point ' + i}</name><Point><coordinates>${n.latlng.lng},${n.latlng.lat},0</coordinates></Point></Placemark>`);
        repeaters.forEach((r) => kml += `<Placemark><name>Relay ${r.id}${r.overBudget ? ' (EXTRA)' : ''}</name><Point><coordinates>${r.latlng.lng},${r.latlng.lat},0</coordinates></Point></Placemark>`);
        kml += `</Document></kml>`;
        const blob = new Blob([kml], { type: 'application/vnd.google-earth.kml+xml' });
        const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'roadside_mesh.kml'; a.click();
    }

    function resetApp() { location.reload(); }
    function resetMapOnly() {
        nodes.forEach(n => map.removeLayer(n.marker));
        repeaters.forEach(r => map.removeLayer(r.marker));
        polylines.forEach(p => map.removeLayer(p));
        nodes = []; repeaters = []; polylines = []; existingLinkKeys.clear(); connectedNodeIds.clear(); activeLinks = [];
        currentStep = 'BASE';
        document.getElementById('add-node-btn').style.display = 'flex';
        document.getElementById('calc-btn').style.display = 'none';
        document.getElementById('export-btn').disabled = true;
        document.getElementById('mesh-summary').style.display = 'none';
        updateUI('Set Command Center', 'STEP 1', '#eee');
    }
    function closeProfile() { document.getElementById('profile-viewer').style.display = 'none'; }
    function updateUI(sub, step, color) {
        document.getElementById('ui-subtitle').innerText = sub;
        const badge = document.getElementById('step-badge');
        badge.innerText = step; badge.style.background = color;
    }
    function logToMesh(msg) {
        const log = document.getElementById('mesh-log');
        log.innerHTML = `<div>> ${msg}</div>` + log.innerHTML;
        log.scrollTop = 0;
    }
    window.onload = init;
</script>
</body>
</html>
