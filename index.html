<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>868MHz Fresnel Mesh Planner</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        :root { 
            --primary: #2c3e50; 
            --mesh-blue: #3498db; 
            --danger: #e74c3c; 
            --warning: #f1c40f; 
            --success: #2ecc71; 
            --bg: #f8f9fa;
            --accent: #9b59b6;
            --desperation: #e67e22;
        }
        body { margin: 0; padding: 0; font-family: -apple-system, system-ui, sans-serif; overflow: hidden; background: var(--bg); }
        
        #map { height: 100vh; width: 100vw; z-index: 1; transition: filter 0.5s ease; cursor: crosshair; }
        
        /* Nav Moved to Top-Left */
        #controls {
            position: absolute; top: 10px; left: 10px;
            z-index: 1000; background: white; padding: 18px; border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3); width: 300px;
            border: 1px solid rgba(0,0,0,0.1);
            max-height: 90vh; overflow-y: auto;
        }

        .header { margin-bottom: 12px; border-bottom: 1px solid #eee; padding-bottom: 10px; }
        .title-group h1 { font-size: 1.1rem; margin: 0; color: var(--primary); font-weight: 800; }
        .title-group p { font-size: 0.7rem; margin: 0; color: #7f8c8d; font-weight: 600; }
        
        .status-badge { 
            display: inline-block; font-size: 0.65rem; font-weight: 800; 
            padding: 3px 8px; border-radius: 12px; background: #eee; 
            margin-top: 5px; color: #555;
        }
        
        .btn-group { display: flex; flex-direction: column; gap: 8px; margin-top: 10px; }
        button { 
            padding: 12px; border: none; border-radius: 8px; cursor: pointer; 
            font-weight: 700; font-size: 0.8rem; transition: all 0.2s ease;
            display: flex; align-items: center; justify-content: center; gap: 8px;
            width: 100%;
        }
        button:hover { filter: brightness(95%); transform: translateY(-1px); }
        button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        
        .btn-main { background: var(--mesh-blue); color: white; }
        .btn-calc { background: var(--success); color: white; }
        .btn-alt { background: #f1f2f6; color: var(--primary); }
        .btn-view { background: var(--accent); color: white; }
        .btn-export { background: #34495e; color: white; }

        #processing-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255, 255, 255, 0.8); z-index: 2000;
            display: none; flex-direction: column; align-items: center; justify-content: center;
            backdrop-filter: blur(5px);
        }
        
        .loader-box { text-align: center; color: var(--primary); }
        .spinner { width: 40px; height: 40px; border: 4px solid #ddd; border-top: 4px solid var(--mesh-blue); border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 15px auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        #prompt-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5); z-index: 3000;
            display: none; align-items: center; justify-content: center;
        }
        .modal { background: white; padding: 25px; border-radius: 16px; width: 90%; max-width: 320px; box-shadow: 0 20px 40px rgba(0,0,0,0.4); }
        .input-row { margin-bottom: 15px; }
        .input-row label { display: block; font-size: 0.75rem; font-weight: 700; margin-bottom: 5px; color: #555; }
        .modal input { width: 100%; padding: 10px; border: 2px solid #eee; border-radius: 8px; font-size: 1rem; }

        #mesh-log { 
            margin-top: 15px; max-height: 150px; overflow-y: auto; 
            font-size: 0.7rem; color: #666; background: #f8f9fa; 
            padding: 8px; border-radius: 8px; border: 1px solid #eee;
            font-family: monospace;
        }
        
        #profile-viewer {
            position: absolute; bottom: 20px; right: 20px; width: 300px;
            background: white; z-index: 1000; border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2); padding: 15px;
            display: none;
        }
        #profile-canvas { width: 100%; height: 120px; background: #f4f4f4; border-radius: 6px; }

        /* Marker Styles */
        .repeater-pulse { 
            background: var(--accent); border: 2px solid white; border-radius: 50%; 
            color: white; font-weight: bold; font-size: 10px;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        .road-pulse {
            background: var(--mesh-blue); border: 2px solid white; border-radius: 50%;
            color: white; font-weight: bold; font-size: 10px;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        .desperation-pulse {
            background: var(--desperation); border: 2px solid white; border-radius: 50%; 
            color: white; font-weight: bold; font-size: 10px;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>

<div id="processing-overlay">
    <div class="loader-box">
        <div class="spinner"></div>
        <div style="font-weight: 800; font-size: 1.2rem;">CALCULATING MESH</div>
        <div id="proc-label" style="font-size: 0.9rem; margin-top: 5px;">Analyzing Topology...</div>
        <div id="proc-bar" style="width: 200px; height: 4px; background: #eee; margin: 10px auto; border-radius: 2px; overflow:hidden;">
            <div id="proc-fill" style="width: 0%; height: 100%; background: var(--success); transition: width 0.3s;"></div>
        </div>
    </div>
</div>

<div id="prompt-overlay">
    <div class="modal">
        <h3>Mission Parameters</h3>
        <div class="input-row">
            <label>NODES TO CONNECT</label>
            <input type="number" id="node-count-input" value="1" min="1" max="50">
        </div>
        <div class="input-row">
            <label>INITIAL REPEATER BUDGET</label>
            <input type="number" id="repeater-budget-input" value="10" min="1" max="200">
        </div>
        <button class="btn-main" onclick="confirmSetup()">Start Placement</button>
    </div>
</div>

<div id="profile-viewer">
    <div style="display:flex; justify-content:space-between; margin-bottom:5px;">
        <span style="font-weight:800; font-size:0.75rem;">LINK PROFILE</span>
        <button onclick="closeProfile()" style="padding:2px 6px; font-size:0.7rem; width:auto;">X</button>
    </div>
    <canvas id="profile-canvas"></canvas>
    <div id="profile-stats" style="font-size:0.7rem; margin-top:5px; color:#555;"></div>
</div>

<div id="controls">
    <div class="header">
        <div class="title-group">
            <h1>Roadside Mesh Planner</h1>
            <p>6dBi / 15km Max Hop / 3m Height</p>
        </div>
        <div id="status-badge" class="status-badge">SETUP REQUIRED</div>
    </div>

    <div class="btn-group">
        <button class="btn-main" id="add-node-btn" onclick="triggerAddNode()">üìç Place Node</button>
        <button class="btn-calc" id="calc-btn" onclick="runMeshSolver()" disabled>‚ö° SOLVE PATHS</button>
        <button class="btn-view" onclick="toggleViewshed()">üëÅÔ∏è Toggle Viewshed</button>
        <button class="btn-export" id="export-btn" onclick="exportKML()" disabled>üíæ Export KML</button>
        <button class="btn-alt" onclick="resetMap()">üîÑ Reset Map</button>
    </div>
    
    <div id="mesh-log">Waiting for input...</div>
</div>

<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
    // --- GLOBAL CONSTANTS ---
    const ANT_H = 3.0; // 3 meters
    const MAX_HOP_KM = 15; // 15km limit for 6dBi
    const EARTH_K = 1.333;
    const EARTH_R = 6371;
    const ZOOM_LEVEL = 14; 
    const ROAD_THRESHOLD = 750; 

    const COLORS = {
        primary: '#2c3e50',
        meshBlue: '#3498db',
        danger: '#e74c3c',
        warning: '#f1c40f',
        success: '#2ecc71',
        accent: '#9b59b6',
        desperation: '#e67e22'
    };

    const VIEWSHED_PALETTE = [
        '#e74c3c', '#3498db', '#2ecc71', '#9b59b6', 
        '#f1c40f', '#e67e22', '#1abc9c', '#d35400', 
        '#2980b9', '#8e44ad', '#27ae60', '#16a085', '#f39c12', '#c0392b'
    ];

    // --- GLOBAL STATE ---
    let map;
    let tileCache = new Map();
    let nodes = []; 
    let repeaters = []; 
    let links = [];
    let roadPoints = []; 
    let activeViewshedLayer = null;
    let targetCount = 0;
    let budget = 0;
    let currentStep = 'SETUP';
    let rCounter = 1;
    let viewshedMode = false;
    let existingLinkKeys = new Set();
    let connectedNodeIds = new Set([0]);

    // --- UTILS & DATA FETCHING ---
    const decodeHeight = (r, g, b) => (r * 256 + g + b / 256) - 32768;
    const lon2tile = (lon, z) => Math.floor((lon + 180) / 360 * Math.pow(2, z));
    const lat2tile = (lat, z) => Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, z));

    async function getElevation(lat, lng) {
        const x = lon2tile(lng, ZOOM_LEVEL);
        const y = lat2tile(lat, ZOOM_LEVEL);
        const key = `${ZOOM_LEVEL}/${x}/${y}`;
        if (!tileCache.has(key)) {
            try {
                const img = new Image(); img.crossOrigin = "Anonymous";
                await new Promise((res, rej) => {
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = 256; canvas.height = 256;
                        canvas.getContext('2d').drawImage(img, 0, 0);
                        tileCache.set(key, canvas); res();
                    };
                    img.onerror = rej;
                    img.src = `https://s3.amazonaws.com/elevation-tiles-prod/terrarium/${ZOOM_LEVEL}/${x}/${y}.png`;
                });
            } catch (e) { return 0; }
        }
        const canvas = tileCache.get(key);
        if (!canvas) return 0;
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const n = Math.pow(2, ZOOM_LEVEL);
        const px = Math.floor(((lng + 180) / 360 * n % 1) * 256);
        const py = Math.floor(((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * n % 1) * 256);
        const p = ctx.getImageData(px, py, 1, 1).data;
        return decodeHeight(p[0], p[1], p[2]);
    }

    async function loadRoads() {
        let bounds = map.getBounds();
        let q = `[out:json];way["highway"](${bounds.getSouth()},${bounds.getWest()},${bounds.getNorth()},${bounds.getEast()});(._;>;);out body;`;
        try {
            let res = await fetch('https://overpass-api.de/api/interpreter', { method: 'POST', body: q });
            let data = await res.json();
            roadPoints = [];
            data.elements.forEach(e => {
                if (e.type === 'node') roadPoints.push(L.latLng(e.lat, e.lon));
            });
            log(`Loaded ${roadPoints.length} road points.`);
        } catch(e) { 
            log("Road fetch failed (Demo Mode)");
            roadPoints = []; 
        }
    }

    async function generateCandidates() {
        let candidates = [];
        // Add road points
        for (let i=0; i<roadPoints.length; i+=10) { 
             let pt = roadPoints[i];
             candidates.push({ latlng: pt, isRoad: true });
        }
        // Add grid points
        let bounds = map.getBounds();
        let steps = 30; 
        let latStep = (bounds.getNorth() - bounds.getSouth()) / steps;
        let lngStep = (bounds.getEast() - bounds.getWest()) / steps;
        for(let r=0; r<steps; r++) {
            for(let c=0; c<steps; c++) {
                let lat = bounds.getSouth() + r*latStep;
                let lng = bounds.getWest() + c*lngStep;
                let pt = L.latLng(lat, lng);
                candidates.push({ latlng: pt, isRoad: false });
            }
        }
        return candidates;
    }

    async function analyzeLink(p1, p2) {
        let dist = p1.distanceTo(p2);
        let samples = 20;
        let isClear = true;
        let startAlt = await getElevation(p1.lat, p1.lng) + ANT_H;
        let endAlt = await getElevation(p2.lat, p2.lng) + ANT_H;
        for(let i=1; i<samples; i++) {
            let frac = i/samples;
            let lat = p1.lat + (p2.lat - p1.lat)*frac;
            let lng = p1.lng + (p2.lng - p1.lng)*frac;
            let terrainAlt = await getElevation(lat, lng);
            let losHeight = startAlt + (endAlt - startAlt)*frac;
            let d1 = (dist * frac) / 1000;
            let d2 = (dist * (1-frac)) / 1000;
            let curve = (d1*d2*1000) / (2 * EARTH_K * EARTH_R);
            if (terrainAlt > (losHeight - curve - 5)) { isClear = false; break; }
        }
        return { clear: isClear, dist: dist };
    }

    // --- UI & APP LOGIC ---

    function init() {
        map = L.map('map', { zoomControl: false, preferCanvas: true }).setView([-33.95, 18.85], 12);
        L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', { maxZoom: 17 }).addTo(map);
        L.control.zoom({ position: 'topright' }).addTo(map);
        map.createPane('viewshedPane'); // Custom pane for viewshed
        map.getPane('viewshedPane').style.zIndex = 650; 
        map.getPane('viewshedPane').style.pointerEvents = 'none'; 
        map.on('click', onMapClick);
        document.getElementById('prompt-overlay').style.display = 'flex';
    }

    function confirmSetup() {
        targetCount = parseInt(document.getElementById('node-count-input').value);
        budget = parseInt(document.getElementById('repeater-budget-input').value);
        document.getElementById('prompt-overlay').style.display = 'none';
        currentStep = 'PLACING';
        updateStatus("Place Base Station");
        log("Mission: Base + " + targetCount + " Nodes. Budget: " + budget);
    }

    function triggerAddNode() {
        if(currentStep === 'DONE') {
            currentStep = 'PLACING';
            updateStatus("Adding extra node...");
        }
    }

    function onMapClick(e) {
        if (viewshedMode) {
             renderViewshed(e.latlng);
             return;
        }

        if (currentStep === 'PLACING') {
            let type = nodes.length === 0 ? 'BASE' : 'NODE';
            let color = type === 'BASE' ? '#2c3e50' : '#3498db';
            let marker = L.circleMarker(e.latlng, { radius: 8, color: 'white', fillColor: color, fillOpacity: 1, weight: 2 }).addTo(map);
            marker.bindTooltip(type + " " + (nodes.length)).openTooltip();
            nodes.push({ latlng: e.latlng, type: type, id: nodes.length, marker: marker });
            
            if (nodes.length > targetCount) {
                currentStep = 'READY';
                document.getElementById('calc-btn').disabled = false;
                document.getElementById('add-node-btn').innerText = "‚ûï Add More";
                updateStatus("Ready to Solve");
            } else {
                updateStatus(`Place Node ${nodes.length} of ${targetCount}`);
            }
        }
    }

    async function runMeshSolver() {
        setBusy(true, "Scanning Road Network...");
        await loadRoads();
        setBusy(true, "Building Terrain Graph...");
        const candidates = await generateCandidates();

        let connectedSet = new Set([0]); 
        repeaters.forEach(r => map.removeLayer(r.marker));
        links.forEach(l => map.removeLayer(l));
        repeaters = []; links = []; rCounter = 1;

        let targets = nodes.slice(1).sort((a,b) => a.latlng.distanceTo(nodes[0].latlng) - b.latlng.distanceTo(nodes[0].latlng));

        for (let i=0; i<targets.length; i++) {
            let target = targets[i];
            setBusy(true, `Solving Path to Node ${target.id}...`, (i/targets.length)*100);
            
            let bestPath = null;
            let bestCost = Infinity;

            let potentialSources = [nodes[0], ...nodes.slice(1).filter(n => connectedSet.has(n.id)), ...repeaters];
            potentialSources.sort((a,b) => a.latlng.distanceTo(target.latlng) - b.latlng.distanceTo(target.latlng));
            potentialSources = potentialSources.slice(0, 3);

            for (let src of potentialSources) {
                let path = await checkDirectLink(src, target);
                if (path) {
                    if (path.cost < bestCost) { bestCost = path.cost; bestPath = path.chain; }
                    continue; 
                }

                let roadCandidates = candidates.filter(c => c.isRoad);
                let roadChain = await findAStarPath(src, target, roadCandidates, true); 
                if (roadChain && roadChain.cost < bestCost) {
                    bestCost = roadChain.cost; bestPath = roadChain.path;
                }

                if (!bestPath) {
                    let wildChain = await findAStarPath(src, target, candidates, false);
                    if (wildChain && wildChain.cost < bestCost) {
                        bestCost = wildChain.cost; bestPath = wildChain.path;
                    }
                }
            }

            if (bestPath) {
                deployPath(bestPath, target);
                connectedSet.add(target.id);
            } else {
                log("FAILED to reach Node " + target.id + ". Showing theoretical line.");
                let failLine = L.polyline([nodes[0].latlng, target.latlng], { color: 'red', dashArray: '5,5', weight: 2 }).addTo(map);
                links.push(failLine);
            }
        }

        setBusy(false);
        document.getElementById('export-btn').disabled = false;
        updateStatus("Mesh Optimized");
    }

    async function checkDirectLink(src, target) {
        let dist = src.latlng.distanceTo(target.latlng);
        if (dist > MAX_HOP_KM * 1000) return null;
        let analysis = await analyzeLink(src.latlng, target.latlng);
        if (analysis.clear) return { cost: dist, chain: [] };
        return null;
    }

    async function findAStarPath(start, end, graph, roadBias) {
        let open = [{ node: start, g: 0, f: 0, path: [] }];
        let closed = new Set();
        let loops = 0;
        while(open.length > 0 && loops < 2000) {
            loops++;
            open.sort((a,b) => a.f - b.f);
            let current = open.shift();

            let distToEnd = current.node.latlng.distanceTo(end.latlng);
            if (distToEnd < MAX_HOP_KM * 1000) {
                 let finalLeg = await analyzeLink(current.node.latlng, end.latlng);
                 if (finalLeg.clear) return { cost: current.g + distToEnd, path: current.path };
            }

            let neighbors = graph.filter(n => {
                let d = current.node.latlng.distanceTo(n.latlng);
                return d > 200 && d < MAX_HOP_KM * 1000;
            });
            neighbors.sort((a,b) => a.latlng.distanceTo(end.latlng) - b.latlng.distanceTo(end.latlng));
            
            for(let i=0; i<Math.min(neighbors.length, 10); i++) {
                let neighbor = neighbors[i];
                let key = neighbor.latlng.lat + "," + neighbor.latlng.lng;
                if (closed.has(key)) continue;
                
                let link = await analyzeLink(current.node.latlng, neighbor.latlng);
                if (link.clear) {
                    let moveCost = current.node.latlng.distanceTo(neighbor.latlng);
                    if (roadBias && !neighbor.isRoad) moveCost *= 10; 
                    let newG = current.g + moveCost;
                    let newF = newG + neighbor.latlng.distanceTo(end.latlng);
                    open.push({ node: neighbor, g: newG, f: newF, path: [...current.path, neighbor] });
                    closed.add(key);
                }
            }
        }
        return null;
    }

    function deployPath(path, target) {
        let bestSrc = nodes[0];
        let minD = Infinity;
        let firstPt = path.length > 0 ? path[0] : target;
        
        [...nodes.slice(0,1), ...nodes.slice(1).filter(n=>connectedNodeIds.has(n.id)), ...repeaters].forEach(n => {
             let d = n.latlng.distanceTo(firstPt.latlng);
             if (d < minD) { minD = d; bestSrc = n; }
        });
        
        let lastPos = bestSrc.latlng;
        
        if (path.length === 0) {
             drawLink(bestSrc.latlng, target.latlng, '#2ecc71');
             log("Direct link: " + bestSrc.id + " -> " + target.id);
             return;
        }

        path.forEach(pt => {
             let type = pt.isRoad ? 'ROAD' : 'PEAK';
             let color = pt.isRoad ? '#3498db' : '#e67e22'; 
             let icon = L.divIcon({ className: pt.isRoad ? 'road-pulse' : 'repeater-pulse', html: rCounter++, iconSize: [24,24] });
             let rMarker = L.marker(pt.latlng, {icon: icon}).addTo(map);
             rMarker.bindTooltip(`R${rCounter-1} (${type})`);
             repeaters.push({ latlng: pt.latlng, marker: rMarker, id: 'R'+(rCounter-1) });
             drawLink(lastPos, pt.latlng, '#f1c40f');
             lastPos = pt.latlng;
        });

        drawLink(lastPos, target.latlng, '#f1c40f');
        log(`Chain deployed to ${target.id} (${path.length} hops).`);
    }

    function drawLink(p1, p2, color) {
        let line = L.polyline([p1, p2], { color: color, weight: 3, opacity: 0.8 }).addTo(map);
        line.on('click', () => showProfile(p1, p2));
        links.push(line);
    }

    function setBusy(isBusy, msg, percent) {
        let el = document.getElementById('processing-overlay');
        el.style.display = isBusy ? 'flex' : 'none';
        if(msg) document.getElementById('proc-label').innerText = msg;
        if(percent) document.getElementById('proc-fill').style.width = percent + '%';
    }

    function updateStatus(msg, badgeTxt, badgeColor) {
        document.getElementById('mesh-log').innerText = msg;
        if(badgeTxt) {
            let b = document.getElementById('status-badge');
            b.innerText = badgeTxt;
            b.style.background = badgeColor;
            b.style.color = 'white';
        }
    }
    
    function log(msg) {
        let l = document.getElementById('mesh-log');
        l.innerHTML = `<div>> ${msg}</div>` + l.innerHTML;
    }
    
    function resetMap() {
        location.reload();
    }
    
    function resetMapOnly() {
        location.reload();
    }

    function closeProfile() {
        document.getElementById('profile-viewer').style.display = 'none';
    }
    
    function exportKML() {
        let kml = `<?xml version="1.0" encoding="UTF-8"?><kml xmlns="http://www.opengis.net/kml/2.2"><Document><name>Roadside Mesh Plan</name>`;
        nodes.forEach((n, i) => kml += `<Placemark><name>${i === 0 ? 'Command Center' : 'Point ' + i}</name><Point><coordinates>${n.latlng.lng},${n.latlng.lat},0</coordinates></Point></Placemark>`);
        repeaters.forEach((r) => kml += `<Placemark><name>Relay ${r.id}</name><Point><coordinates>${r.latlng.lng},${r.latlng.lat},0</coordinates></Point></Placemark>`);
        kml += `</Document></kml>`;
        const blob = new Blob([kml], { type: 'application/vnd.google-earth.kml+xml' });
        const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'roadside_mesh.kml'; a.click();
    }

    function showProfile(p1, p2) {
        document.getElementById('profile-viewer').style.display = 'block';
        let ctx = document.getElementById('profile-canvas').getContext('2d');
        ctx.clearRect(0,0,300,150);
        ctx.fillStyle = '#f4f4f4'; ctx.fillRect(0,0,300,150);
        ctx.fillStyle = '#666'; ctx.fillText("Profile View Placeholder", 80, 75);
    }
    
    // --- VIEWSHED LOGIC ---
    function toggleViewshed() {
        viewshedMode = !viewshedMode;
        if(viewshedMode) {
             updateStatus("Tap map to see Coverage Cloak", "VIEWSHED", COLORS.accent);
             renderAllViewsheds();
        } else {
             if(activeViewshedLayer) map.removeLayer(activeViewshedLayer);
             updateStatus("Resume Planning", "READY", COLORS.meshBlue);
        }
    }

    async function renderAllViewsheds() {
        if(activeViewshedLayer) map.removeLayer(activeViewshedLayer);
        setBusy(true, "Initializing Coverage Scan...");
        await new Promise(r => setTimeout(r, 50));
        
        activeViewshedLayer = L.layerGroup({pane: 'viewshedPane'});
        
        // 1. Base + Field Nodes + Repeaters
        let allDevices = [...nodes, ...repeaters];

        if (allDevices.length === 0) {
            setBusy(false);
            return;
        }

        for (let i = 0; i < allDevices.length; i++) {
            let device = allDevices[i];
            let name = device.type === 'BASE' ? 'Base Station' : (device.id.toString().startsWith('R') ? `Relay ${device.id}` : `Node ${device.id}`);
            
            setBusy(true, `Scanning Coverage: ${name}...`, (i / allDevices.length) * 100);
            await new Promise(r => setTimeout(r, 10)); // Yield to UI
            
            let color = VIEWSHED_PALETTE[i % VIEWSHED_PALETTE.length];
            let pts = await computeRadialViewshed(device.latlng, 20000);
            
            pts.forEach(pt => {
                L.circleMarker(pt, { 
                    radius: 1, 
                    stroke: false, 
                    fillOpacity: 0.5, 
                    fillColor: color, 
                    interactive: false 
                }).addTo(activeViewshedLayer);
            });
        }
        
        activeViewshedLayer.addTo(map);
        setBusy(false);
        updateStatus("Multi-Color Coverage Active", "VISIBLE", COLORS.accent);
    }

    async function renderViewshed(latlng) {
         // Single click viewshed logic (retained for manual checks)
         if(activeViewshedLayer) map.removeLayer(activeViewshedLayer);
         setBusy(true, "Computing Single Cloak...");
         await new Promise(r => setTimeout(r, 50));
         
         let visiblePoints = await computeRadialViewshed(latlng, 20000);
         activeViewshedLayer = L.layerGroup({pane: 'viewshedPane'});
         visiblePoints.forEach(pt => {
              L.circleMarker(pt, { radius: 1, stroke: false, fillOpacity: 0.8, fillColor: 'red', interactive: false }).addTo(activeViewshedLayer);
         });
         activeViewshedLayer.addTo(map);
         setBusy(false);
    }

    async function computeRadialViewshed(center, radiusMeters) {
        // 720 rays = 0.5 degree res
        const sourceAlt = await getElevation(center.lat, center.lng) + ANT_H;
        let visiblePoints = [];
        const rays = 720; 
        const stepSize = 100; 

        for (let angle = 0; angle < 360; angle += (360/rays)) {
            if (angle % 20 === 0) await new Promise(r => setTimeout(r, 0)); 

            const rad = angle * (Math.PI / 180);
            let maxAngle = -9999; 
            
            for (let d = stepSize; d <= radiusMeters; d += stepSize) {
                const lat = center.lat + (d * Math.cos(rad) / 111320);
                const lng = center.lng + (d * Math.sin(rad) / (111320 * Math.cos(center.lat * (Math.PI/180))));
                
                const terrainAlt = await getElevation(lat, lng);
                const curvatureDrop = (d * d) / (2 * EARTH_K * EARTH_R * 1000);
                const heightDiff = terrainAlt - sourceAlt - curvatureDrop;
                const elevationAngle = Math.atan(heightDiff / d);

                if (elevationAngle >= maxAngle) {
                    maxAngle = elevationAngle;
                    visiblePoints.push(L.latLng(lat, lng));
                }
            }
        }
        return visiblePoints;
    }

    window.onload = init;
</script>
</body>
</html>
